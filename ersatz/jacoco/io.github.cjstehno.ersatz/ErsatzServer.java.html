<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ErsatzServer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ersatz</a> &gt; <a href="index.source.html" class="el_package">io.github.cjstehno.ersatz</a> &gt; <span class="el_source">ErsatzServer.java</span></div><h1>ErsatzServer.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2023 Christopher J. Stehno
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.cjstehno.ersatz;

import io.github.cjstehno.ersatz.cfg.Expectations;
import io.github.cjstehno.ersatz.cfg.ServerConfig;
import io.github.cjstehno.ersatz.cfg.WaitFor;
import io.github.cjstehno.ersatz.impl.ServerConfigImpl;
import io.github.cjstehno.ersatz.server.UnderlyingServer;
import io.github.cjstehno.ersatz.server.undertow.UndertowUnderlyingServer;
import lombok.Getter;

import java.io.Closeable;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import static io.github.cjstehno.ersatz.cfg.WaitFor.atMost;
import static java.util.concurrent.TimeUnit.SECONDS;
import static lombok.AccessLevel.PROTECTED;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * The main entry point for configuring an Ersatz server, which allows configuring of the expectations and management of the server itself. This is
 * the class that should be instantiated in unit tests.
 * &lt;p&gt;
 * The server will be started on an ephemeral port so as not to collide with itself or other server applications running in the test environment. In
 * your tests, you can retrieve the server port or URL using the &lt;code&gt;getPort()&lt;/code&gt; and &lt;code&gt;getServerUrl()&lt;/code&gt; methods respectively.
 * &lt;p&gt;
 * Using the &lt;code&gt;ErsatzServer&lt;/code&gt; follows the workflow:
 *
 * &lt;ol&gt;
 *     &lt;li&gt;Create the &lt;code&gt;ErsatzServer&lt;/code&gt; instance.&lt;/li&gt;
 *     &lt;li&gt;Configure the expectations.&lt;/li&gt;
 *     &lt;li&gt;Start the server&lt;/li&gt;
 *     &lt;li&gt;Run your client tests against the server.&lt;/li&gt;
 *     &lt;li&gt;Verify the expectations.&lt;/li&gt;
 *     &lt;li&gt;Stop the server.&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;p&gt;
 * See the &lt;a href=&quot;http://cjstehno.github.io/ersatz/asciidoc/html5/&quot; target=&quot;_blank&quot;&gt;User Guide&lt;/a&gt; for more detailed information.
 */
public class ErsatzServer implements Closeable {

    private final UnderlyingServer underlyingServer;
<span class="nc" id="L58">    @Getter(PROTECTED) private final ServerConfigImpl serverConfig;</span>

    /**
     * Creates a new Ersatz server instance with empty (default) configuration.
     */
    public ErsatzServer() {
<span class="fc" id="L64">        this(new ServerConfigImpl());</span>
<span class="fc" id="L65">    }</span>

    /**
     * Creates a new Ersatz server instance with the provided configuration.
     *
     * @param config the configuration instance.
     */
<span class="fc" id="L72">    public ErsatzServer(final ServerConfig config) {</span>
<span class="fc" id="L73">        this.serverConfig = (ServerConfigImpl) config;</span>
<span class="fc" id="L74">        this.serverConfig.setStarter(this::start);</span>

<span class="fc" id="L76">        this.underlyingServer = new UndertowUnderlyingServer(serverConfig);</span>
<span class="fc" id="L77">    }</span>

    /**
     * Creates a new Ersatz server instance configured by the provided &lt;code&gt;Consumer&lt;/code&gt;, which will have an instance of &lt;code&gt;ServerConfig&lt;/code&gt;
     * passed into it for server configuration.
     *
     * @param consumer the configuration consumer
     */
    public ErsatzServer(final Consumer&lt;ServerConfig&gt; consumer) {
<span class="fc" id="L86">        this();</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (consumer != null) {</span>
<span class="fc" id="L88">            consumer.accept(serverConfig);</span>
        }
<span class="fc" id="L90">    }</span>

    /**
     * Used to retrieve the port where the HTTP server is running.
     *
     * @return the HTTP port
     */
    public int getHttpPort() {
<span class="fc" id="L98">        return underlyingServer.getActualHttpPort();</span>
    }

    /**
     * Used to retrieve the port where the HTTPS server is running.
     *
     * @return the HTTPS port
     */
    public int getHttpsPort() {
<span class="fc" id="L107">        return underlyingServer.getActualHttpsPort();</span>
    }

    /**
     * Used to retrieve the HTTP or HTTPS port where the server is running, based on the value of the boolean passed in.
     * This method is useful for test cases where the SSL state is parameterized.
     *
     * @param https whether the retrieved port is for HTTPS.
     * @return the port value, or -1 if not available.
     */
    public int getPort(final boolean https) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        return https ? getHttpsPort() : getHttpPort();</span>
    }

    /**
     * Used to retrieve whether HTTPS is enabled or not.
     *
     * @return true if HTTPS is enabled
     */
    public boolean isHttpsEnabled() {
<span class="fc" id="L127">        return serverConfig.isHttpsEnabled();</span>
    }

    /**
     * Used to retrieve the full URL of the HTTP server.
     *
     * @return the full URL of the HTTP server
     */
    public String getHttpUrl() {
<span class="fc" id="L136">        return getUrl(&quot;http&quot;, getHttpPort());</span>
    }

    /**
     * Used to retrieve the full URL of the HTTPS server.
     *
     * @return the full URL of the HTTP server
     */
    public String getHttpsUrl() {
<span class="fc" id="L145">        return getUrl(&quot;https&quot;, getHttpsPort());</span>
    }

    /**
     * Used to retrieve the Web Socket URL.
     *
     * @return the web socket URL
     */
    public String getWsUrl() {
<span class="fc" id="L154">        return getUrl(&quot;ws&quot;, getHttpPort());</span>
    }

    /**
     * Used to retrieve the Web Socket URL with the appended path.
     *
     * @param path the path to be appended to the web socket url
     * @return the web socket url with the appended path
     */
    public String wsUrl(final String path) {
<span class="fc" id="L164">        return getWsUrl() + path;</span>
    }

    /**
     * Used to retrieve the full url of the server, either HTTP or HTTPS, based on the passed in boolean value. This
     * method is useful for testing in cases where the HTTPS enablement is parameterized.
     * &lt;p&gt;
     * If the scheme is not available, the port value in the URL will be -1.
     *
     * @param https whether the retrieved URL is for HTTPS or not
     * @return the full url of the server for the scheme (HTTPS or HTTP).
     */
    public String getUrl(final boolean https) {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        return https ? getHttpsUrl() : getHttpUrl();</span>
    }

    private static String getUrl(final String prefix, final int port) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (port &gt; 0) {</span>
<span class="fc" id="L182">            return prefix + &quot;://localhost:&quot; + port;</span>
        } else {
<span class="fc" id="L184">            throw new IllegalStateException(&quot;The port (&quot; + port + &quot;) is invalid: Has the server been started?&quot;);</span>
        }
    }

    /**
     * A helper method which may be used to append the given path to the server HTTP url.
     *
     * @param path the path to be applied
     * @return the resulting URL
     */
    public String httpUrl(final String path) {
<span class="fc" id="L195">        return getHttpUrl() + path;</span>
    }

    /**
     * A helper method which may be used to append the given path to the server HTTPS url.
     *
     * @param path the path to be applied
     * @return the resulting URL
     */
    public String httpsUrl(final String path) {
<span class="fc" id="L205">        return getHttpsUrl() + path;</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided &lt;code&gt;Consumer&amp;lt;Expectations&amp;gt;&lt;/code&gt; implementation will have an active
     * &lt;code&gt;Expectations&lt;/code&gt; object passed into it for configuring server interaction expectations.
     * &lt;p&gt;
     * Calling this method when auto-start is enabled will start the server.
     *
     * @param expects the &lt;code&gt;Consumer&amp;lt;Expectations&amp;gt;&lt;/code&gt; instance to perform the configuration
     * @return a reference to this server
     */
    public ErsatzServer expectations(final Consumer&lt;Expectations&gt; expects) {
<span class="fc" id="L218">        serverConfig.expectations(expects);</span>

<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (serverConfig.isAutoStartEnabled()) {</span>
<span class="fc" id="L221">            underlyingServer.start();</span>
        }

<span class="fc" id="L224">        return this;</span>
    }

    /**
     * An alternate means of starting the expectation chain.
     * &lt;p&gt;
     * Calling this method when auto-start is enabled will &lt;b&gt;NOT&lt;/b&gt; start the server. Use one of the other expectation configuration method if
     * auto-start functionality is desired.
     *
     * @return the reference to the Expectation configuration object
     */
    public Expectations expects() {
<span class="fc" id="L236">        return serverConfig.expects();</span>
    }

    /**
     * Used to specify the server request timeout property value on the server.
     * &lt;p&gt;
     * The IDLE_TIMEOUT, NO_REQUEST_TIMEOUT, REQUEST_PARSE_TIMEOUT, READ_TIMEOUT and WRITE_TIMEOUT are all configured to the same specified
     * value.
     *
     * @param value the timeout value
     * @param units the units the timeout is specified with
     * @return a reference to the server being configured
     */
    public ServerConfig timeout(final int value, final TimeUnit units) {
<span class="nc" id="L250">        return serverConfig.timeout(value, units);</span>
    }

    /**
     * Used to specify the server request timeout property value on the server (in seconds).
     * &lt;p&gt;
     * The IDLE_TIMEOUT, NO_REQUEST_TIMEOUT, REQUEST_PARSE_TIMEOUT, READ_TIMEOUT and WRITE_TIMEOUT are all configured to the same specified
     * value.
     *
     * @param value the timeout value
     * @return a reference to the server being configured
     */
    public ServerConfig timeout(final int value) {
<span class="nc" id="L263">        return timeout(value, SECONDS);</span>
    }

    /**
     * Used to start the HTTP server for test interactions. This method should be called after configuration of expectations and before the test
     * interactions are executed against the server.
     *
     * @return a reference to this server
     */
    public ErsatzServer start() {
<span class="fc" id="L273">        underlyingServer.start();</span>
<span class="fc" id="L274">        return this;</span>
    }

    /**
     * Clears all configured expectations from the server. Does not affect global encoders or decoders.
     */
    public void clearExpectations() {
<span class="fc" id="L281">        serverConfig.clearExpectations();</span>
<span class="fc" id="L282">    }</span>

    /**
     * Used to stop the HTTP server. The server may be restarted after it has been stopped.
     */
    public void stop() {
<span class="fc" id="L288">        underlyingServer.stop();</span>
<span class="fc" id="L289">    }</span>

    /**
     * An alias to the &lt;code&gt;stop()&lt;/code&gt; method.
     */
    @Override
    public void close() {
<span class="fc" id="L296">        stop();</span>
<span class="fc" id="L297">    }</span>

    /**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back
     * from the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @param timeout the timeout value
     * @param unit    the timeout unit
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     * @deprecated Use the &lt;code&gt;verify(WaitFor)&lt;/code&gt; version instead
     */
    @Deprecated(since = &quot;4.0.0&quot;, forRemoval = true)
    public boolean verify(final long timeout, final TimeUnit unit) {
<span class="fc" id="L311">        return verify(atMost(timeout, unit));</span>
    }

    /**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back
     * from the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @param waitFor the timeout waiting value
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     */
    public boolean verify(final WaitFor waitFor) {
<span class="fc" id="L323">        return serverConfig.getExpectations().verify(waitFor);</span>
    }

    /**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back
     * from the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @param timeout the timeout value (in seconds)
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     * @deprecated Use the &lt;code&gt;verify(WaitFor)&lt;/code&gt; version instead
     */
    @Deprecated(since = &quot;4.0.0&quot;, forRemoval = true)
    public boolean verify(final long timeout) {
<span class="nc" id="L337">        return verify(timeout, SECONDS);</span>
    }

    /**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back
     * from the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     */
    public boolean verify() {
<span class="fc" id="L348">        return verify(1, SECONDS);</span>
    }

    /**
     * Helper method to wrap a call to the &lt;code&gt;verify()&lt;/code&gt; method within a JUnit &lt;code&gt;assertTrue(...)&lt;/code&gt; call.
     *
     * This method applies a 1 second waiting time before timing out.
     */
    public void assertVerified() {
<span class="fc" id="L357">        assertVerified(WaitFor.ONE_SECOND);</span>
<span class="fc" id="L358">    }</span>

    /**
     * Helper method to wrap a call to the &lt;code&gt;verify(timeout, unit)&lt;/code&gt; method within a JUnit &lt;code&gt;assertTrue(...)&lt;/code&gt; call.
     *
     * @param waitFor the amount of time the verification should wait before considering a timeout.
     */
    public void assertVerified(final WaitFor waitFor) {
<span class="fc" id="L366">        assertTrue(verify(waitFor), &quot;The server expectation verification failed.&quot;);</span>
<span class="fc" id="L367">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>