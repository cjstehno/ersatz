<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ErsatzServer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ersatz</a> &gt; <a href="index.source.html" class="el_package">io.github.cjstehno.ersatz</a> &gt; <span class="el_source">ErsatzServer.java</span></div><h1>ErsatzServer.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2023 Christopher J. Stehno
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.cjstehno.ersatz;

import io.github.cjstehno.ersatz.cfg.Expectations;
import io.github.cjstehno.ersatz.cfg.ServerConfig;
import io.github.cjstehno.ersatz.impl.ServerConfigImpl;
import io.github.cjstehno.ersatz.server.UnderlyingServer;
import io.github.cjstehno.ersatz.server.undertow.UndertowUnderlyingServer;

import java.io.Closeable;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import static java.util.concurrent.TimeUnit.SECONDS;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * The main entry point for configuring an Ersatz server, which allows configuring of the expectations and management of the server itself. This is
 * the class that should be instantiated in unit tests.
 * &lt;p&gt;
 * The server will be started on an ephemeral port so as not to collide with itself or other server applications running in the test environment. In
 * your tests, you can retrieve the server port or URL using the &lt;code&gt;getPort()&lt;/code&gt; and &lt;code&gt;getServerUrl()&lt;/code&gt; methods respectively.
 * &lt;p&gt;
 * Using the &lt;code&gt;ErsatzServer&lt;/code&gt; follows the workflow:
 *
 * &lt;ol&gt;
 *     &lt;li&gt;Create the &lt;code&gt;ErsatzServer&lt;/code&gt; instance.&lt;/li&gt;
 *     &lt;li&gt;Configure the expectations.&lt;/li&gt;
 *     &lt;li&gt;Start the server&lt;/li&gt;
 *     &lt;li&gt;Run your client tests against the server.&lt;/li&gt;
 *     &lt;li&gt;Verify the expectations.&lt;/li&gt;
 *     &lt;li&gt;Stop the server.&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;p&gt;
 * See the &lt;a href=&quot;http://cjstehno.github.io/ersatz/asciidoc/html5/&quot; target=&quot;_blank&quot;&gt;User Guide&lt;/a&gt; for more detailed information.
 */
public class ErsatzServer implements Closeable {

    private final UnderlyingServer underlyingServer;
    private final ServerConfigImpl serverConfig;

    /**
     * Creates a new Ersatz server instance with empty (default) configuration.
     */
    public ErsatzServer() {
<span class="fc" id="L60">        this(new ServerConfigImpl());</span>
<span class="fc" id="L61">    }</span>

    /**
     * Creates a new Ersatz server instance with the provided configuration.
     *
     * @param config the configuration instance.
     */
<span class="fc" id="L68">    public ErsatzServer(final ServerConfig config) {</span>
<span class="fc" id="L69">        this.serverConfig = (ServerConfigImpl) config;</span>
<span class="fc" id="L70">        this.serverConfig.setStarter(this::start);</span>

<span class="fc" id="L72">        this.underlyingServer = new UndertowUnderlyingServer(serverConfig);</span>
<span class="fc" id="L73">    }</span>

    /**
     * Creates a new Ersatz server instance configured by the provided &lt;code&gt;Consumer&lt;/code&gt;, which will have an instance of &lt;code&gt;ServerConfig&lt;/code&gt;
     * passed into it for server configuration.
     *
     * @param consumer the configuration consumer
     */
    public ErsatzServer(final Consumer&lt;ServerConfig&gt; consumer) {
<span class="fc" id="L82">        this();</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (consumer != null) {</span>
<span class="fc" id="L84">            consumer.accept(serverConfig);</span>
        }
<span class="fc" id="L86">    }</span>

    /**
     * Used to retrieve the port where the HTTP server is running.
     *
     * @return the HTTP port
     */
    public int getHttpPort() {
<span class="fc" id="L94">        return underlyingServer.getActualHttpPort();</span>
    }

    /**
     * Used to retrieve the port where the HTTPS server is running.
     *
     * @return the HTTPS port
     */
    public int getHttpsPort() {
<span class="fc" id="L103">        return underlyingServer.getActualHttpsPort();</span>
    }

    /**
     * Used to retrieve whether HTTPS is enabled or not.
     *
     * @return true if HTTPS is enabled
     */
    public boolean isHttpsEnabled() {
<span class="fc" id="L112">        return serverConfig.isHttpsEnabled();</span>
    }

    /**
     * Used to retrieve the full URL of the HTTP server.
     *
     * @return the full URL of the HTTP server
     */
    public String getHttpUrl() {
<span class="fc" id="L121">        return getUrl(&quot;http&quot;, getHttpPort());</span>
    }

    /**
     * Used to retrieve the full URL of the HTTPS server.
     *
     * @return the full URL of the HTTP server
     */
    public String getHttpsUrl() {
<span class="fc" id="L130">        return getUrl(&quot;https&quot;, getHttpsPort());</span>
    }

    private static String getUrl(final String prefix, final int port) {
<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (port &gt; 0) {</span>
<span class="fc" id="L135">            return prefix + &quot;://localhost:&quot; + port;</span>
        } else {
<span class="fc" id="L137">            throw new IllegalStateException(&quot;The port (&quot; + port + &quot;) is invalid: Has the server been started?&quot;);</span>
        }
    }

    /**
     * A helper method which may be used to append the given path to the server HTTP url.
     *
     * @param path the path to be applied
     * @return the resulting URL
     */
    public String httpUrl(final String path) {
<span class="fc" id="L148">        return getHttpUrl() + path;</span>
    }

    /**
     * A helper method which may be used to append the given path to the server HTTPS url.
     *
     * @param path the path to be applied
     * @return the resulting URL
     */
    public String httpsUrl(final String path) {
<span class="fc" id="L158">        return getHttpsUrl() + path;</span>
    }

    /**
     * Used to configure HTTP expectations on the server; the provided &lt;code&gt;Consumer&amp;lt;Expectations&amp;gt;&lt;/code&gt; implementation will have an active
     * &lt;code&gt;Expectations&lt;/code&gt; object passed into it for configuring server interaction expectations.
     * &lt;p&gt;
     * Calling this method when auto-start is enabled will start the server.
     *
     * @param expects the &lt;code&gt;Consumer&amp;lt;Expectations&amp;gt;&lt;/code&gt; instance to perform the configuration
     * @return a reference to this server
     */
    public ErsatzServer expectations(final Consumer&lt;Expectations&gt; expects) {
<span class="fc" id="L171">        serverConfig.expectations(expects);</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (serverConfig.isAutoStartEnabled()) {</span>
<span class="fc" id="L174">            underlyingServer.start();</span>
        }

<span class="fc" id="L177">        return this;</span>
    }

    /**
     * An alternate means of starting the expectation chain.
     * &lt;p&gt;
     * Calling this method when auto-start is enabled will &lt;b&gt;NOT&lt;/b&gt; start the server. Use one of the other expectation configuration method if
     * auto-start functionality is desired.
     *
     * @return the reference to the Expectation configuration object
     */
    public Expectations expects() {
<span class="fc" id="L189">        return serverConfig.expects();</span>
    }

    /**
     * Used to specify the server request timeout property value on the server.
     * &lt;p&gt;
     * The IDLE_TIMEOUT, NO_REQUEST_TIMEOUT, REQUEST_PARSE_TIMEOUT, READ_TIMEOUT and WRITE_TIMEOUT are all configured to the same specified
     * value.
     *
     * @param value the timeout value
     * @param units the units the timeout is specified with
     * @return a reference to the server being configured
     */
    public ServerConfig timeout(final int value, final TimeUnit units) {
<span class="nc" id="L203">        return serverConfig.timeout(value, units);</span>
    }

    /**
     * Used to specify the server request timeout property value on the server (in seconds).
     * &lt;p&gt;
     * The IDLE_TIMEOUT, NO_REQUEST_TIMEOUT, REQUEST_PARSE_TIMEOUT, READ_TIMEOUT and WRITE_TIMEOUT are all configured to the same specified
     * value.
     *
     * @param value the timeout value
     * @return a reference to the server being configured
     */
    public ServerConfig timeout(final int value) {
<span class="nc" id="L216">        return timeout(value, SECONDS);</span>
    }

    /**
     * Used to start the HTTP server for test interactions. This method should be called after configuration of expectations and before the test
     * interactions are executed against the server.
     *
     * @return a reference to this server
     */
    public ErsatzServer start() {
<span class="fc" id="L226">        underlyingServer.start();</span>
<span class="fc" id="L227">        return this;</span>
    }

    /**
     * Clears all configured expectations from the server. Does not affect global encoders or decoders.
     */
    public void clearExpectations() {
<span class="fc" id="L234">        serverConfig.clearExpectations();</span>
<span class="fc" id="L235">    }</span>

    /**
     * Used to stop the HTTP server. The server may be restarted after it has been stopped.
     */
    public void stop() {
<span class="fc" id="L241">        underlyingServer.stop();</span>
<span class="fc" id="L242">    }</span>

    /**
     * An alias to the &lt;code&gt;stop()&lt;/code&gt; method.
     */
    @Override
    public void close() {
<span class="fc" id="L249">        stop();</span>
<span class="fc" id="L250">    }</span>

    /**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back
     * from the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @param timeout the timeout value
     * @param unit    the timeout unit
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     */
    public boolean verify(final long timeout, final TimeUnit unit) {
<span class="fc" id="L262">        return serverConfig.getExpectations().verify(timeout, unit);</span>
    }

    /**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back
     * from the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @param timeout the timeout value (in seconds)
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     */
    public boolean verify(final long timeout) {
<span class="nc" id="L274">        return verify(timeout, SECONDS);</span>
    }

    /**
     * Used to verify that all of the expected request interactions were called the appropriate number of times. This method should be called after
     * all test interactions have been performed. This is an optional step since generally you will also be receiving the expected response back
     * from the server; however, this verification step can come in handy when simply needing to know that a request is actually called or not.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all call criteria were met during test execution.
     */
    public boolean verify() {
<span class="fc" id="L285">        return verify(1, SECONDS);</span>
    }

    /**
     * Helper method to wrap a call to the &lt;code&gt;verify()&lt;/code&gt; method within a JUnit &lt;code&gt;assertTrue(...)&lt;/code&gt; call.
     */
    public void assertVerified() {
<span class="fc" id="L292">        assertTrue(verify(), &quot;The server expectation verification failed.&quot;);</span>
<span class="fc" id="L293">    }</span>

    /**
     * Retrieves the internal server configuration.
     *
     * @return the server configuration for this server.
     */
    protected final ServerConfigImpl getServerConfig() {
<span class="nc" id="L301">        return serverConfig;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>